\documentclass[a4paper,10pt,headlines=3.2]{scrartcl}
\usepackage{graphicx}           %Bilder

%\usepackage[T1]{fontenc}        %Umlaute
%\usepackage[latin1]{inputenc}   %Windows
%\usepackage[utf8x]{inputenc}	%Linux
\usepackage{ucs}

\usepackage[ngerman]{babel}     %Deutsche Sprache
\usepackage{amsmath}            %Math. Zeichen
\usepackage{pifont}             %Skalierbare Schriftart
\usepackage{array}
\usepackage{epsfig}             %Erweiterte Grafiken
\usepackage{makeidx}            %Stichwortverzeichnis
\usepackage[pdftex]{color} 

\newcommand{\changefont}[3]{
\fontfamily{#1} \fontseries{#2} \fontshape{#3} \selectfont}

\makeindex

\usepackage[automark]{scrpage2}
\usepackage[nosectionbib]{apacite}               %Zitieren

%\usepackage[colorlinks]{hyperref}%Hyperlinks

\usepackage{lmodern}
\usepackage{scrpage2}           %KOMA-Script
\usepackage{tipa}
\usepackage{qtree}

\usepackage{remreset}			%Fussnoten global
\makeatletter
\@removefromreset{footnote}{chapter}
\makeatother 

\setcounter{tocdepth}{3}

%Kopfzeilen
\pagestyle{scrheadings}         %Seitenstil scrheadings verwenden

%\setlength{\textheight}{24cm}
%\setlength{\textwidth}{16cm}
%\setlength{\topmargin}{-2cm}
%\setlength{\oddsidemargin}{0cm}

% Groesse des Textbereiches in der Seite
\setlength{\textwidth}{16cm}
\setlength{\textheight}{22cm}
% Kopf- und Fusszeile, Hoehe und Abstand vom Text
\setlength{\headheight}{15pt}
\setlength{\headsep}{0.8cm}
% Linker Seiteneinzug
\setlength{\oddsidemargin}{2.5cm} \addtolength{\oddsidemargin}{-1in}
\setlength{\evensidemargin}{2.5cm} \addtolength{\evensidemargin}{-1in}
% Andere Groessen ausrechnen (vertikal zentrieren)
\setlength{\footskip}{\headsep}
\addtolength{\footskip}{\headheight}
\setlength{\topmargin}{\paperheight}
\addtolength{\topmargin}{-\textheight}
\addtolength{\topmargin}{-\headheight}
\addtolength{\topmargin}{-\headsep}
\addtolength{\topmargin}{-\footskip}
\addtolength{\topmargin}{-2in}
\addtolength{\topmargin}{-0.5\topmargin}

%Schriftart
\changefont{cmss}{m}{n} \normalsize

%Abstand zurücksetzen
\setlength{\headheight}{20pt}

\usepackage{listings} 
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt} \lstset{language=Java} 

\clearscrheadfoot
%\renewcommand{\headheight}{40pt} 
\ihead[]{Datenstrukturen und Algorithmen \\Frühlingssemester 2011 \\Institut für angewandte Mathematik} % - linke Kopfzeile 
\ohead[asdasd]{Übungsblatt 1 \\Abgabetermin 3. März 2011 \\Adrianus Kleemans [07-111-693]} % - linke Kopfzeile 
\setheadsepline{.4pt} %Separate Linie im Kopf
\cfoot[\pagemark]{\pagemark} %- mittlere Fusszeile 

\begin{document}
\section*{Grundlagen}
\subsection*{Aufgabe 1}
\begin{eqnarray}
\sum\limits_{k=1}^n (2k-1) \Rightarrow 2 \cdot \sum\limits_{k=1}^n k - \sum\limits_{k=1}^n 1 \\
\textrm{Mit } \sum\limits_{i=1}^n (i) = \frac{n\cdot (n+1)}{2} \\
\Rightarrow 2 \cdot \frac{n\cdot(n+1)}{2} - n \Rightarrow n^2
\end{eqnarray}
  
\subsection*{Aufgabe 2}
\begin{eqnarray}
\prod\limits_{k=1}^n 2\cdot 4^{k} \Rightarrow \prod\limits_{k=1}^n 2 \cdot \prod\limits_{k=1}^n 4^{k} \\
\prod\limits_{k=1}^n 2 = 2^{n} \\
\prod\limits_{k=1}^n 4^{k} = 4^{\frac{n^2}{2} + \frac{n}{2}} \\
\Rightarrow 2^n \cdot 4^{\frac{n^2}{2} + \frac{n}{2}} \\
\Rightarrow 2^n \cdot 4^{\frac{n^2}{2}} \cdot 4^{\frac{n}{2}} \\
\Rightarrow 2^n \cdot 2^{n^2} \cdot 2^{n}  \\
\Rightarrow 2^{n^2} \cdot 2^{2n} \Rightarrow 2^{n^2} \cdot 4^{n}
\end{eqnarray}

\subsection*{Aufgabe 3}
\begin{eqnarray}
\sum\limits_{k=1}^n \frac{1}{k^2} \leq 1 + 1 - \frac{1}{n} \\
\textrm{Verankerung: } n=1. \sum\limits_{k=1}^1 \frac{1}{k^2} = 1 \\
\textrm{Schritt: } \sum\limits_{k=1}^{n+1} \frac{1}{k^2} \leq 1 + 1 - \frac{1}{n+1} \\
\sum\limits_{k=1}^n \frac{1}{k^2} + \frac{1}{(n+1)^2} = (2 - \frac{1}{n}) + \frac{1}{(n+1)^2} \\
\Rightarrow 2 - \frac{1}{n} \\
\Rightarrow -\frac{1}{n}+\frac{1}{(n+1)^2} \leq -\frac{1}{n+1} \textrm{, welches für alle n kleiner 1 stimmt}
\end{eqnarray}

\section*{Theoretische Aufgaben}
\subsection*{Aufgabe 1}
Der InsertionSort-Algorithmus ist relativ einfach zu erklären: \\Eine Variable \texttt{key} wird iteriert, und anschliessend mit den vorderen Elementen verglichen. Ist das Element kleiner, wird es verschoben, wenn nicht, iteriert \texttt{key}.
\begin{figure}[!ht]
\centering
\includegraphics[width=.85\linewidth]{T1}
\caption{Funktionsweise des InsertionSort-Algorithmus.}
\label{pic:t1}
\end{figure}

\subsection*{Aufgabe 2}
Der MergeSort-Algorithmus hingegen ist etwas schwerer zu erklären, und Abb. \ref{pic:t1} soll versuchen aufzuzeigen, dass zuerst in Rekursionsschritten versucht wird, solange aufzuteilen, bis die kleinste Einheit von 2 Elementen erreicht wird. \\Danach werden diese sortiert, und es werden die zwei (vorsortierten) neuen Elemente miteinander zusammengefügt\footnote{Dies in einer Art, dass bei beiden vom Element 0 an aufwärts geschaut wird, welches der beiden zusammenzufügenden Teile das kleiner Element hat. Dieses wird herausgepickt, und dann wird wieder das nächstgrössere Element gesucht, solange, bis alle Elemente zum sortierten Teil hinzugefügt wurden.}, sodass auch diese Einheit wieder sortiert ist. Dies wird fortgesetzt bis die ganze Eingabe vollständig sortiert ist.
\begin{figure}[!ht]
\centering
\includegraphics[width=\linewidth]{T2}
\caption{Funktionsweise des MergeSort-Algorithmus.}
\label{pic:t2}
\end{figure}

\subsection*{Aufgabe 3}
\lstset{frame=single}

\begin{lstlisting}[caption=Suche im unsortierten Feld]{Name}
search(int[] A, int v)

for i = 0 to A.length()
   if A[i] = v return v
return NULL
\end{lstlisting}

Bedingung: Das ganze Array wurde durchlaufen und der Index von v, wenn gefunden, ausgegeben. \\
Schleifeninvariante: Das Array wurde von 0 bis i-1 durchsucht.\\
Terminierungsbedingung: i = Länge des Arrays\\\\
Gültigkeit der Schleifeninvariante:
\begin{itemize}
 \item \textbf{Vor der Schleife:} i muss korrekt initialisiert werden. Dies wird mit i = 0 erreicht, indem i den index des ersten Elements von A annimmt.
 \item \textbf{Während der Schleife:} i wird laufend nur um eins erhöht, und da dies gilt, wurde nach Durchlauf A immer bis A[i] durchsucht, und mit der if-Prüfung würde, falls v gefunden würde, die Schleife terminiert werden.
 \item \textbf{Terminierung:} Die Schleife kann während der Schleife, also währenddem $0 \leq i < A.length()$ gilt, abgebrochen werden, tut dies aber auf jeden Fall, wenn i die Länge des Arrays erreicht.
\end{itemize}

Worst-Case-Laufzeit für diesen Algorithmus ist $T(n) = O(n)$, also dass alle Elemente einmal durchlaufen werden müssen (wenn v nicht gefunden wurde).

\subsection*{Aufgabe 4}

\begin{lstlisting}[caption=Suche in sortiertem Feld]{Name}
search(int[] A, int v)

//dist: Grösse des zu durchsuchenden verbleibenden Feldes
dist = (A.length)/2 + 1
//k: Index des mittleren Feldes des aktuellen Suchfeldes
k = dist

while dist >= 1
  //test if number is found
  if A[k] = v then return k

  //change k
  dist = dist/2
  if A[k] < v then k = k + dist
  else if A[k] > v then k = k - dist

return NULL

\end{lstlisting}

Bedingung: Das ganze Array wurde durchlaufen und der Index von v, wenn gefunden, ausgegeben. \\
Schleifeninvariante: Ist der gesuchte Eintrag gerade an Stelle k, soll der Index zurückgegeben werden. Falls nicht, soll je nachdem die grössere oder kleinere verbleibende Hälfte untersucht werden.\\
Terminierungsbedingung: Wenn das gesuchte Element gefunden wurde oder der zu untersuchende Bereich kleiner als 1 Element ist, soll abgebrochen werden.\\\\
Gültigkeit der Schleifeninvariante:
\begin{itemize}
 \item \textbf{Vor der Schleife:} k muss korrekt initialisiert werden. Dies wird mit k = dist = 'die Hälfte der Array-Länge' erreicht, indem k und dist den index des mittleren Elements von A annimmt.
 \item \textbf{Während der Schleife:} Entspricht der mittlere Eintrag dem gesuchten Element, wird dies zurückgegeben. Falls dies nicht der Fall ist, wird der Suchbereich halbiert und k erhält den Index der Mitte des Bereichs, dabei wird bei geraden Bereichen (welche 2 mittlere Elemente haben) immer die kleinere mögliche Mitte gewählt\footnote{Der Eintrag wird durch den Typ (Integer) bedingten Wegfall von Nachkommastellen immer auf den kleineren möglichen Wert gesetzt. Bei vier Elementen zum Beispiel wird 2.5 auf 2 abgerundet, was das zweite Element als Resultat ergibt.}.
 \item \textbf{Terminierung:} Wenn der Wert gefunden wurde, der $A[k] = v$ entspricht, wird der Index zurückgegeben. Falls nicht, wird solange weitergesucht, bis das Suchfeld die Grösse 1 hat, was also heisst, dass das verbleibende Element entweder die Lösung ist oder nicht. Wenn ja, wird diese zurückgegeben, wenn nicht, hält die Schleife durch die Anfangsbedingung (dist >= 1) an. Es wird hier bewusst der Operator >= gewählt, denn wenn das Suchfeld auf 1 verkleinert wurde, muss dieses zuerst noch geprüft werden, ob sich das gesuchte Element darin befindet. Wenn dies nicht der Fall ist, wird das Suchfeld auf einen Wert unter 1 verkleinert und die Schleife bricht ab.
\end{itemize}

Worst-Case-Laufzeit für diesen Algorithmus ist $T(n) = O(log(n))$, weil für die Verdoppelung der Elemente (z.B. von 32 auf 64) nur 1 Schritt mehr gemacht werden muss (von 5 auf 6 Schritte). Dies natürlich, weil die Anzahl der zu durchsuchenden Elemente bei jedem Durchgang halbiert werden kann (die obere oder die untere Hälfte fällt ja jedesmal weg).

\section*{Praktische Aufgaben}
\subsection*{Testprogramm}
Siehe Anhang.

\subsection*{Auswertung der Testfälle}
\begin{figure}
\centering
\includegraphics[width=\linewidth]{graph}
\caption{Darstellung der ermittelten Funktionswerte des Testprogramms.}
\label{pic:graph}
\end{figure}

Gemäss der Abb. \ref{pic:graph}\footnote{Es wurde hier zur besseren Darstellung die logarithmische Skalierung der X-Achse gewählt.} lässt sich zeigen, dass für die gegebenen Datenpunkte relativ genau mit den Erwartungen aus der Theorie übereinstimmen.\\
Die Konstanten c1 und c2 wurden so gewählt, dass sich die Angleichung optimal anzeigen lässt\footnote{Für diesen Fall mit den ermittelten Spezifikationen wurden folgende Werte gewählt: $c1 = 8000, c2 = 600$}.
Die Fluktuationen bei geringen Werten war zu erwarten, und bestätigt die Vermutung, dass bei diesen Werten von $n$ andere Faktoren eine grössere Rolle spielen, welche aber dann bei grösseren $n$ in den Hintergrund rücken.
\\\\
Spezifikationen Computer: \\
Name: Acer Aspire One \\
Intel Atom N450 (1.66 GHz, 512 KB Cache) \\
1 GB RAM \\
\subsection*{Schätzung InsertionSort}
Ermittle konstanter Faktor c aus Testprogramm: $c = \frac{T_{i}}{n^2_{i}}$, daraus folgt $c = 2.8 \cdot 10^{-9}$, \\
Daraus folgt bei $n = 10'000'000 \Rightarrow$ etwa 280'000 Sekunden, also etwa 3.25 Tage.

\end{document}
